function matrix fill (const matrix f,
                      const matrix xcoord)
    n = rows(f)
    valid = selifr(seq(1,n)', ok(f))
    nv = rows(valid)

    if nv < 2
        return {}
    endif

    to_fill = diff(valid)[2:] .> 1
    fills = selifr(valid[1:nv-1] ~ valid[2:nv], to_fill)
    ret = f
    nf = rows(fills)
    loop i = 1 .. nf
        lo = fills[i,1]
        hi = fills[i,2]
        xlo = xcoord[lo]
        xhi = xcoord[hi]
        d = (f[hi] - f[lo]) / (xhi - xlo)
        v = f[lo] + (xcoord[lo+1:hi-1] - xlo) * d
        ret[lo+1:hi-1] = v'
    endloop
    return ret
end function

function matrices fkd (const series x,
                       const series d,
                       bundle opts)
    v = values(d)
    nv = rows(v)
    matrix f = {}
    matrix kept = {}

    if nv > opts.MAXVAL
        printf "Too many values for factor (%d, max. 12)\n", nv
        return defarray(f, kept)
    endif

    matrices ret = array(2)
    matrix X = {}
    matrix Y = {}

    loop i = 1 .. nv
        di = v[i]
        series tmp = d == di ? x : NA
        nn = nobs(tmp)

        if nn >= opts.MINOBS
            kept ~= i

            # TODO: We may want to store the optimal bandwidths
            if opts.scale == -1
                scalar scale = optimal_bandwidth(tmp, opts)
            else
                scalar scale = opts.scale
            endif

            matrix kd = kdensity(tmp, scale, opts.control)

            n = rows(kd)
            X |= kd[,1]
            Yi = mshape(NA, n, nv)
            Yi[,i] = kd[,2]
            Y |= Yi
        endif
    endloop
    nk = nelem(kept)

    if nk > 0
        # fill up the NAs
        scalar n = rows(X)
        X = msortby(seq(1, n)' ~ X, 2)
        ndx = X[,1]
        X = X[,2]
        Z = mshape(NA, n, nk)

        loop i = 1 .. nk
            j = kept[i]
            Z[,i] = fill(Y[ndx,j], X)
        endloop

        # set up the column names
        f = Z ~ X
        strs = strvals(d, 1)
        if nelem(strs)
            strings clabels = strs[kept]
        else
            matrix v = values(d)
            strings clabels = array(nk)
            loop i = 1 .. nk
                clabels[i] = sprintf("%s = %d", opts.dname, v[kept[i]])
            endloop
        endif
        clabels = clabels + defarray(opts.xname)
        cnameset(f, clabels)
        ret = defarray(f, kept)
    endif
    return ret
end function


function scalar optimal_bandwidth (const series y,
                                   const bundle opts)
    /* Compute the optimal bandwidth using the KdeBandwidth package.
    return: scalar, optimal bandwidth */

    scalar bw = kde_bandwidth({y},
                              opts.bw_method,
                              opts.bw_df,
                              opts.bw_skip_na,
                              opts.bw_verbose)

    return bw
end function


function bundle fkd_defopts (void)
    /* Bundle holding default values. */

    bundle ret = _(auto_dashtype = FALSE,
                   auto_pointtype = FALSE,
                   bw_method = "silverman",
                   bw_skip_na = TRUE,
                   bw_df = TRUE,
                   bw_verbose = FALSE,
                   control = 0,
                   dest = "display",
                   fontsize = 10,
                   fontsize_tics = 10,
                   grid = FALSE,
                   linewidth = 1,
                   MINOBS = 30,
                   MAXVAL = 12,
                   monochrome = FALSE,
                   nokey = FALSE,
                   pointsize = 0.75,
                   scale = 1,
                   single_yaxis = FALSE,
                   title = "",
                   ylabel = "",
                   xlabel = "",
                   add_opts = "")

    return ret
end function


function bundle fdensity (const series x,
                          const series d,
                          bundle opts_in[null])
    bundle opts = fkd_defopts()
    if exists(opts_in)
        opts = opts_in + opts
    endif

    opts.xname = argname(x)
    if strlen(opts.xname) == 0
        opts.xname = "(anonymous)"
    endif

    opts.dname = argname(d)
    if strlen(opts.dname) == 0
        opts.dname = "(anonymous)"
    endif

    if strlen(opts.title)
        opts.title = opts.title
    else
        opts.title = sprintf("Kernel density of %s by %s",
                             opts.xname, opts.dname)
    endif

    matrices f_k = fkd(x, d, opts)
    kept = f_k[2]
    bundle ret = opts
    ret.err = 0

    if nelem(kept) == 0
        printf "Invalid conditioning\n"
        ret.err = 1
        return ret
    endif

    matrix f = f_k[1]
    ret.kept = kept
    ret.f = f

    plot_fdensity(ret, opts)

    return ret
end function


function void plot_fdensity (const bundle input,
                             const bundle opts)
    /* code description
    return: type, description */

    matrix fdata = input.f
    string dest = opts.dest
    string plot_options = opts.auto_pointtype == TRUE ? "with-lp " : \
                         "with-lines "
    plot_options += opts.single_yaxis == TRUE ? "single-yaxis " : ""

    string linetype_options = ""
    if opts.auto_dashtype || opts.auto_pointtype || opts.monochrome
        linetype_options = "set for [i=1:8] linetype i "
        if opts.auto_dashtype
            linetype_options += "dashtype i "
        endif
        if opts.auto_pointtype
            linetype_options += sprintf("pointtype i ps %g ", opts.pointsize)
        endif
        if opts.monochrome
            linetype_options += "lc rgb 'black"
        endif
    endif

    string key_opts = opts.nokey == TRUE ? "set nokey" : ""
    string grid_opts = opts.grid == TRUE ? "set grid" : ""

    plot fdata
        option @plot_options
        printf "%s", linetype_options
        printf "set termoption lw %d", opts.linewidth
        printf "set title \"%s\" font ',%d'", opts.title, opts.fontsize
        printf "set ylabel \"%s\" font ',%d'", opts.ylabel, opts.fontsize
        printf "set xlabel \"%s\" font ',%d'", opts.xlabel, opts.fontsize
        printf "set xtics font ',%d'", opts.fontsize_tics
        printf "set ytics font ',%d'", opts.fontsize_tics
        printf "%s", key_opts
        printf "%s", grid_opts
        printf "%s", opts.add_opts
    end plot --output="@dest"
end function



function bundle fdensity_GUI (const series x,
                              const series d,
                              scalar scale[0::1],
                              int control[0:1:0] {"Gaussian", "Epanechnikov"})
    xname = argname(x)
    dname = argname(d)
    title = sprintf("Kernel density of %s by %s", xname, dname)

    bundle opts = fkd_defopts()
    if exists(opts_in)
        opts = opts_in + opts
    endif

    matrices f_k = fkd(x, d, xname, dname, scale, control)
    kept = f_k[2]
    bundle ret = opts
    ret.err = 0

    if nelem(kept) == 0
        funcerr "Invalid conditioning"
        ret.err = 1
        return ret
    endif

    matrix f = f_k[1]
    ret.kept = kept
    ret.f = f

    plot f
        option with-lines
        printf "set title \"%s\"", title
    end plot --output=display

    return ret
end function
